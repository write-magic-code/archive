# 05 在 React 中的发起请求

> 课程目的
>
> - 了解前端发起请求的方式
> - 了解如何做好异步请求的状态管理
> - 了解如何使用表单元素收集用户输入

## promise 与 async/await（速通版本）

javascript 是一门**单线程的语言**。这意味着当主线程中执行了一个耗时的操作时，这个操作会阻塞主线程，整个页面都会卡住，无法响应用户的操作（设想这样一个场景，你的前端正在请求后端数据，请求需要耗费一秒，因为请求阻塞了线程，而这一整秒用户只能看着不能动），因此 javascript 的异步操作十分常用并且重要。

因此 javascript 提供了一种抽象，即 promise，想象一下 Promise 就像是一个信箱。你向信箱投递一个请求（像寄信一样），然后你可以做别的事情，手头的事情忙完了就看一眼有没有回信，而不用一直等着。最终，当信箱里出现了回信，你就可以拿到这个结果，如果信件在中途丢失了，你也会被告知。

“信箱”带来的的异步机制，使我们代码的控制流跟同步的代码很不一样：

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("done");
  }, 1000);
});

promise
  .then((value) => {
    console.log(value);
  })
  .catch((e) => {
    console.error(e);
  });
```

简单来说，Promise 的构造函数接受一个函数，这个函数有两个参数，一个是 `resolve`，一个是 `reject`。当异步操作成功时，调用 `resolve`，当异步操作失败时，调用 `reject`。`then` 方法接受两个函数，一个是成功时的回调，一个是失败时的回调。

大部分时候编写代码不会直接编写 Promise，只需要得到 Promise 并进行组合，来完成复杂的异步操作，但是这个过程是简单但繁复的，设想这样的场景：   
[promise-hell.js](./promise-hell.js)

因此我们需要一个更方便的方式来组合 Promise（或者说多个异步操作），因此 js 有了 async/await 语法，他支持使用类似同步的语法来组合 Promise：   
[async-await.js](./async-await.js)

标上 `async` 的函数会被特殊处理，它会返回一个 `Promise`，并且你可以在里面使用 `await` 关键字。`await` 可以理解为一个运行时的标记，它会自动帮我们把后面的代码放到 `Promise` 的 `then` 方法中，这样我们就可以像写同步代码一样写异步代码。

## fetch

fetch 是浏览器提供的用于发起请求的 API，它是基于 Promise 设计的，使用起来非常简单：     
[fetchs.js](./fetchs.js)

fetch 十分强大，想继续学习的同学可以看 [fetch-api](https://www.bookstack.cn/read/ruanyifeng-fetch-api/fetch-api.md)，这算是一个比较全面的教程。

## 在 React 中使用 fetch

我们注意到我们编写的组件都是同步的函数，而网络请求是异步的，这就出现了天然割裂，因此只能将异步的操作（或者说 Promise）视为一种副作用，放到 `useEffect` 中执行。

后来 React 实现了 `useSyncExternalStore` 让异步的操作也能纳入 React 的控制之下。因为这个 API 写起来并不如 `useEffect` 那么直观，因此在简单项目中还是使用 `useEffect` 为好，在大型项目中我们会使用如 `swr`、`react-query` 这样的库来管理异步操作，他们的底层是 `useSyncExternalStore`。

[fetch-in-react.jsx](./fetch-in-react.jsx)

当然，日常开发不会这么简单，我们需要处理一些状态，比如 loading、error、data 等，仅仅这样三个需求就让我们的组件多出了三个 `useState`：

```jsx
const Comp = () => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  return <div>{loading ? "loading..." : error ? error : data}</div>;
};
```

而一个 React App 中网络请求不太可能只有一两处，因此在工程中将请求封装出一个通用 hook 是个还不错的实践，我们来自己实现一个：

* src/hooks/useRequest.js
```jsx
import { useEffect, useState } from "react"

export const useRequest(fetcher) {
    const [data, setData] = useState(undefined);
    const [error, setError] = useState(null);
    useEffect(() => {
        fetcher()
            .then((value) => {
                setData(value)
            })
            .catch(e => setError(e))
    }, [])
    return {
        data,
        error,
    }
}
```
* src/components/AnyComponent.jsx
```jsx
const Comp = () => {
    const { data, error } = useRequest(() => fetch("https://api.github.com"));
    return <div>
        {typeof data === 'undefined' ? 'loading' : data}
        {error && error.toString()}
    </div>
};
```

## 表单提交

若要收集信息然后提交给后端，则就需要写表单了：  
[form.jsx](./form.jsx)

一个常见的性能优化点：大部分时候表单业务不需要时刻让输入跟状态保持统一，只需要在提交的时候能拿到最新的值就行了。

这种优化可以通过获取 HTML 元素实例，在提交的时候读取 HTML 元素的值来实现：  
[better-form.jsx](./better-form.jsx)

这里顺便还做了一些优化，比如检查用户的输入内容，这在现实开发中能避免很多不必要的麻烦。
