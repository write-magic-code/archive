# 03 函数式、Hook 与重新渲染

> 课程目的
>
> - 理解 React 的思想
> - 知道 Hook 的来源、规则和意义
> - 学会使用 useState、useRef、useEffect

React 中 UI 的最小可组合单元是组件，组件的 HTML 结构、样式以及状态都在组件内定义，状态的管理是其中最重要的部分，状态的范式直接决定了组件的组织形态。

React 的组件模型在 16.8 之后发生了一次**范式转变**，在今天只需要去学习这个新的范式就够了，但是了解旧的范式对于理解新的范式是有帮助的。

## 旧 React

旧版 React 使用面向对象的模型，一个组件是一个 class，通过重载 class 的属性和方法来绑定状态和行为。

我们来看一个例子：  

[class-comp.jsx](./class-comp.jsx)

其模型比函数组件直观地多：所有的状态都挤在 `this.state` 里，状态更新就执行 `this.setState`，然后因为状态的更新，UI 也会重新渲染。（可以注意到第一节写过一个很类似的东西）。

因为面向对象模型的劣势，需要写大量冗余代码：class component 将混乱状态和行为拆到若干类里，而前端应用的混乱在总体上可能不降反增！**class component 实际上只是提供了一种组织代码的方式，而不是提供了一种更好的编程模型。**

[simple.png](./simple.png) 上半部分的 class 模型示意。

一个 class component 有各种各样的生命周期，比如创建时、挂载前、挂载后、状态更新时、卸载时等等，在不同阶段执行不同操作的同时，也让组件的行为变得不可预测。应用变大，**这些生命周期及状态的组合便会指数级的增长（就如同你没有使用框架时一样）**，这就让应用的行为难预测，难维护。

**总之，class component 被日益增长的业务抛弃了。**

## 现代 React 和函数式

理解生命周期的概念简单，但是管理生命周期极大程度上增加了组件维护成本，当规模大起来的时候，简单就意味着没有限制（尤其是水平次点的团队），没有规范，因此也就失去了可预测性，又因此失去了可维护性——**互相看不懂的屎山就是这么来的。**

因此 React 选择拥抱函数式编程，它的核心思想是**纯函数**：

1. 纯函数就是每次输入相同，输出也一样的函数。它不会读取或修改外部的东西，因此结果一致且可预测，也就好维护。
2. React 要求函数组件是纯函数（或者说 `UI = fn(state)`，显然 state 不变则 UI 不变）。
3. 因此 React 的函数组件行为可预测，可维护。

React 借助引入函数式的理念，丢掉了生命周期，状态就是函数组件编写时唯一需要关注的。而所有状态又是由 React 管理的，因此拥有一整套模型，这个模型被称作 Hook。

可以通过 Hooks 来操作 React 管理下的状态，亦或是处理状态改变时的副作用，而不用再去关心组件的七八个生命周期组合出的指数级增长的状态。

> **注意：React 中，状态管理，和组件渲染是相互独立的。使用 hook 声明状态模型之后，只需消费和操作状态，不要再去关心状态、与组件的绑定与任何的生命周期。**

来看一个例子：

[fn-comp.jsx](./fn-comp.jsx)    

[simple.png](./simple.png) 下半部分的 function component 模型示意。

丢掉了生命周期之后，需要维护的状态都在函数组件的顶部统一定义出来，让状态和行为都更加清晰，极大程度上减少了组件的复杂度。

## Hook 综述

在 React 提供的函数中，有一些 `useXXX` 形式命名的函数被称为 hook，他们是 React 中操作状态的核心。

这些内置的 hook 与 React 的调度器直接绑定，所以 React 可以清楚的知道 hook 在哪个组件的哪个实例中被调用。因此只要同一个组件中的 hook 的调用顺序是确定的，React 就可以确定每一次组件渲染中调用的是哪个 hook，这个 hook 又对应着哪个操作。

既然 React 能将每次 hook 的调用一一对应，那么 hook 对状态的操作就是有迹可循的，无论组件的实例在何时被重新渲染，React 都能将对应的状态绑定到正确的组件，这样就让组件可以稳定的拿到属于自己的状态。

## 操作状态：`useState`

用于在 React 的调度器中声明一个状态变量，这个状态变量会随着组件的整个生命周期存在，在每次重新渲染中拿到。

```jsx
const Component = () => {
  const [count, setCount] = useState(0);

  return (
    <button
      onClick={() => {
        setCount(count + 1);
      }}
    >
      {count}
    </button>
  );
};
```

1. 在组件的顶层调用 useState 来声明一个**状态变量**（并初始化），和一个**setter**
2. 在`onClick`中调用**setter**`setCount`，将 count 设置为`count + 1`
3. 通过**setter**`setCount`的调用，触发状态更新，随后组件重新渲染

> useState 负责更新状态，**之后触发重新渲染**，而在第二次渲染中，count 的值变成了更新后的值，因此 UI 上的 `{count}` 也会变化。

**函数组件中可以有多个`useState`，负责多个状态的更新，同时在更新时触发重新渲染。**

## 在多次渲染中保存一个值：`useRef`

用于在 React 的调度器中声明一个**引用**，这个引用用于包装一个 js 对象，组件的实例在每一次渲染的时候都可以拿到这个引用。

```tsx
const Component = () => {
  const timerRef = useRef(null);
  const start = () => {
    timerRef.current = setInterval(() => {
      console.log("tick");
    }, 1000);
  };
  const stop = () => {
    clearInterval(timerRef.current);
    timerRef.current = null;
  };
  ...
}
```

**如果你希望在函数组件中声明一个不会直接影响 UI 的变量，比如定时器的 ID，或是上次用户点击按钮的时间，那么就可以使用 `useRef`，它返回一个带有 `.current` 属性的对象，这个属性可以随意更改，而不会导致组件重新渲染，但是它与 React 的调度器绑定，所以在每次重新渲染中都可以拿到这个值。**

除此之外，它还可以用于取得与 JSX 对应的真实 DOM 元素，这会在之后的课程中讲到。

## 同步状态 `useEffect`

用于在 React 的调度器中声明一个**副作用函数**，用于在 React 中处理一些不属于 UI 的操作，比如获取数据、手动更改网页元素等。

> 首先 `useEffect` 是一个已经烂掉并且已经被工业界唾弃的 API，大部分情景都不必使用它，只要在项目中发现不得不去用它，那么它极大概率是被误用为**某种临时方案**，这是一个很糟糕的信号。这个示例是一个比较简单的应用，并且这个应用有更好更简单的替代方案，在此处只是为了展示 `useEffect` 的用法。

```tsx
import React, { useEffect } from "react";

const PageLayoutFC = (props) => {
  const { title } = props;

  useEffect(() => {
    const lastTitle = document.title;
    document.title = title;
    return () => {
      document.title = lastTitle;
    };
  }, [title]);

  return (
    <div>
      <h1>{title}</h1>
    </div>
  );
};

export default function App() {
  return <PageLayoutFC title="网站标题"></PageLayoutFC>;
}
```

`useEffect`的使用方法是：传入一个 function + list，解释是：

- 传入一个**副作用函数**（Effect），副作用函数返回一个**清理函数**（Effect Cleaner）
- 传入一个 list（依赖列表）
- 组件初始化时，执行一次 Effect；每次 list 变化时，先执行上一次返回的 Effect Cleaner，再执行一次 Effect。

Effect 和 Cleaner 要求是**同步**执行——这意味着你最好不要在里面加异步操作

由于 `useEffect` 被误用的历史复杂，我们只解释它的两种用法：

- **外部**数据（如浏览器信息、网络请求数据）同步到 React 状态
- React **内部**状态同步到外部

其中，我们只推荐第二种，**从内到外**的同步。

**`useEffect` 是用于处理副作用的 Hook。副作用指的是组件在 React 之外发生的操作，比如更新网页标题、获取数据、设置订阅、API 请求等。**

但是在较新版本的 React 中，处理从外到内同步的 Hook 有了更好的选择，是 React 内置的 `useSyncExternalStore`，它能避免 `useEffect` 中大部分的陷阱，并且比 `useEffect` 直观，但碍于篇幅，细讲它会非常冗长，所以在这里不展开。

同样的事情也发生在从内到外的同步上，或者说 React 的 state 同步到外部，而根据 state 发生变化的原因我们可以做一个简单的二分：

1. 当用户操作的时候更改了 state，比如用户点击了一个勾选框让一个 state 变为 true，则我们可以在**处理点击事件时**直接操作外部的数据，而不需要使用 `useEffect`。
2. 当 state 是由外部数据同步而来的（比如一个 API 请求的结果），那么这里便发生了一个从内到外再到内的同步，是非常吊诡的，完全可以放在请求的时候直接处理，也不需要使用 `useEffect`。

但是在实际业务中，又有极少数的不得已的情况，这种时候就只能使用 `useEffect` 了。

## 自定义 Hook

自定义 Hook 是一种用来复用逻辑的方式，他体现为若干 hook 的组合（如同我们在组件里使用 hook 一样）。

与组件类似，自定义 Hook 是一个函数，只是名字以 `use` 开头，而且一般会返回一些封装后的状态及其操作。

与组件不同的是，自定义 Hook 返回的内容是一些状态和操作状态的函数（当然不返回也行），而不是 JSX。

```tsx
const useCounter = (initialValue) => {
  const [count, setCount] = useState(initialValue);
  const add = () => setCount((count) => count + 1);
  const minus = () => setCount((count) => count - 1);
  return {
    count,
    add,
    minus,
  };
};

const HomePage = () => {
  const { count, add, minus } = useCounter(0);
  return (
    <div>
      <h1>Home</h1>
      <span>{count}</span>
      <button onClick={add}>add</button>
      <button onClick={minus}>minus</button>
    </div>
  );
};
```

这样我们就可以把一些逻辑抽象出来，然后在不同的组件里使用。

## Hook 规则怪谈

尽管很多文章（包括官方文档）都会把 rules of hooks 说的很复杂，但是其实只有两条：

1. 只能在函数组件或者自定义 Hook 中调用 Hook，不能在其他任何地方调用 Hook，包括 class component。
2. 每次渲染的时候，Hook 的调用顺序和数量必须保持不变。

第二条这也就要求了：

1. 不能在循环、条件语句中调用 Hook，因为这样次数可能会变化。
2. 不能在函数组件内部的嵌套函数中调用 Hook，因为这样调用顺序可能会变化。

再简化一下就是一句话：Hook 必须在函数组件的函数体的最顶层或者自定义 Hook 中的顶层调用，不能套在任何的 `{}`、`() => ANYTHING` 里。
